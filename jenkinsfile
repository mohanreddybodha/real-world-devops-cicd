pipeline {
  agent any

  environment {
    IMAGE_NAME   = "mohanreddybodha/feedback"
    IMAGE_TAG    = "v${BUILD_NUMBER}"
    DOCKER_CREDS = "dockerhub-creds"
    SSH_CREDS    = "ec2-ssh-key"

    ANSIBLE_HOST_KEY_CHECKING = "False"
  }

  options {
    timeout(time: 30, unit: 'MINUTES')
    timestamps()
    disableConcurrentBuilds()
  }

  stages {

    /* -------------------- CODE -------------------- */

    stage('Checkout Code') {
      steps {
        checkout scm
      }
    }

    stage('Install Dependencies') {
      parallel {
        stage('Backend Deps') {
          steps { sh 'cd backend && npm install' }
        }
        stage('Frontend Deps') {
          steps { sh 'cd frontend && npm install' }
        }
      }
    }

    stage('Build Frontend') {
      steps {
        sh '''
          cd frontend
          npm run build || echo "Static build skipped"
          mkdir -p ../backend/public
          cp -r dist/* ../backend/public/ || true
        '''
      }
    }

    stage('Test Backend') {
      steps {
        sh 'cd backend && node -c server.js'
      }
    }

    /* -------------------- DOCKER -------------------- */

    stage('Build & Push Docker Image') {
      steps {
        script {
          docker.withRegistry('https://index.docker.io/v1/', DOCKER_CREDS) {
            sh '''
              docker build -t $IMAGE_NAME:$IMAGE_TAG .
              docker push $IMAGE_NAME:$IMAGE_TAG
            '''
          }
        }
      }
    }

    /* -------------------- TERRAFORM -------------------- */

    stage('Terraform Init & Apply') {
      when {
        expression { params.RUN_TERRAFORM }
      }
      steps {
        dir('terraform') {
          sh """
            terraform init -input=false
            terraform apply -auto-approve -input=false 
          """
        }
      }
    }

    /* -------------------- INVENTORY -------------------- */

    stage('Generate Ansible Inventory') {
      steps {
        script {
          env.MASTER_IP = sh(
            script: "cd terraform && terraform output -raw master_ip",
            returnStdout: true
          ).trim()

          def worker_ips = sh(
            script: "cd terraform && terraform output -json worker_ips | jq -r '.[]'",
            returnStdout: true
          ).trim()

          def workers = worker_ips.split('\n')
            .collect { ip ->
              "${ip} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3"
            }.join('\n')

          writeFile file: "ansible/inventory.ini", text: """
[master]
${env.MASTER_IP} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3

[workers]
${workers}
"""
        }
      }
    }

    /* -------------------- ANSIBLE -------------------- */

    stage('Configure Kubernetes Cluster') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh """
              ansible-playbook -i inventory.ini common-modules.yaml
              ansible-playbook -i inventory.ini master.yaml 
              ansible-playbook -i inventory.ini worker.yaml 
              ansible-playbook -i inventory.ini master2.yaml \
                -e cluster_name=kubeadm-cluster \
                -e region=ap-south-1 \
                -e vpc_id=${params.VPC_ID}
            """
          }
        }
      }
    }

    /* -------------------- APPLICATION (APP + INGRESS) -------------------- */

    stage('Deploy Application (App + SVC + Ingress)') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh """
              ansible-playbook -i inventory.ini deploy-app.yaml \
                -e IMAGE_NAME=${IMAGE_NAME} \
                -e IMAGE_TAG=${IMAGE_TAG}
            """
          }
        }
      }
    }

    /* -------------------- FETCH ALB (FIXED) -------------------- */

    stage('Fetch ALB DNS') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          script {
            env.ALB_DNS = sh(
              script: """
                ssh -o StrictHostKeyChecking=no \
                    -o UserKnownHostsFile=/dev/null \
                    ubuntu@${env.MASTER_IP} \
                    "kubectl get ingress -A -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}'"
              """,
              returnStdout: true
            ).trim()

            if (!env.ALB_DNS) {
              error "ALB DNS not available yet"
            }

            echo "Resolved ALB DNS: ${env.ALB_DNS}"
          }
        }
      }
    }

    /* -------------------- MONITORING -------------------- */

    stage('Deploy Monitoring') {
      steps {
        withCredentials([string(credentialsId: 'SLACK_WEBHOOK_URL', variable: 'SLACK_WEBHOOK_URL')]) {
          sshagent(credentials: [SSH_CREDS]) {
            sh '''
              sed "s|__SLACK_WEBHOOK__|$SLACK_WEBHOOK_URL|g" monitoring-values.yaml > monitoring-values-final.yaml

              scp -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  monitoring-values-final.yaml \
                ubuntu@${MASTER_IP}:/tmp/monitoring-values.yaml

              ssh -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  ubuntu@${MASTER_IP} '
                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true &&
                helm repo update &&
                helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
                  -n monitoring \
                  -f /tmp/monitoring-values.yaml \
                  --set alertmanager.alertmanagerSpec.externalUrl=http://${ALB_DNS}/alertmanager \
                  --timeout 15m \
                  --wait
              '
            '''
          }
        }
      }
    }
  }

  post {
    success {
      echo "✅ Infra + App + Ingress + Monitoring deployed successfully"
    }
    failure {
      echo "❌ Pipeline failed. Check logs."
    }
  }
}