pipeline {
  agent any

  parameters {
    booleanParam(
      name: 'RUN_TERRAFORM',
      defaultValue: false,
      description: 'Run Terraform apply (enable ONLY when infra changes)'
    )
  }

  environment {
    IMAGE_NAME   = "mohanreddybodha/feedback"
    IMAGE_TAG    = "v${BUILD_NUMBER}"
    DOCKER_CREDS = "dockerhub-creds"
    SSH_CREDS    = "ec2-ssh-key"

    ANSIBLE_HOST_KEY_CHECKING = "False"
  }

  options {
    timeout(time: 30, unit: 'MINUTES')
    timestamps()
    disableConcurrentBuilds()
  }

  stages {

    /* -------------------- CODE -------------------- */

    stage('Checkout Code') {
      steps {
        checkout scm
      }
    }

    stage('Install Dependencies') {
      parallel {
        stage('Backend Deps') {
          steps { sh 'cd backend && npm install' }
        }
        stage('Frontend Deps') {
          steps { sh 'cd frontend && npm install' }
        }
      }
    }

    stage('Build Frontend') {
      steps {
        sh '''
          cd frontend
          npm run build || echo "Static build skipped"
          mkdir -p ../backend/public
          cp -r dist/* ../backend/public/ || true
        '''
      }
    }

    stage('Test Backend') {
      steps {
        sh 'cd backend && node -c server.js'
      }
    }

    /* -------------------- DOCKER -------------------- */

    stage('Build & Push Docker Image') {
      steps {
        script {
          docker.withRegistry('https://index.docker.io/v1/', DOCKER_CREDS) {
            sh '''
              docker build -t $IMAGE_NAME:$IMAGE_TAG .
              docker push $IMAGE_NAME:$IMAGE_TAG
            '''
          }
        }
      }
    }

    /* -------------------- TERRAFORM -------------------- */

    stage('Terraform Init & Apply') {
      steps {
        dir('terraform') {
          sh '''
            terraform init -input=false
            terraform apply -auto-approve -input=false
          '''
        }
      }
    }

    /* -------------------- INVENTORY -------------------- */

    stage('Generate Ansible Inventory') {
      steps {
        script {
          env.MASTER_IP = sh(
            script: "cd terraform && terraform output -raw master_ip",
            returnStdout: true
          ).trim()

          def worker_ips = sh(
            script: "cd terraform && terraform output -json worker_ips | jq -r '.[]'",
            returnStdout: true
          ).trim()

          def workers = worker_ips.split('\n')
            .collect { ip ->
              "${ip} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3"
            }.join('\n')

          writeFile file: "ansible/inventory.ini", text: """
[master]
${env.MASTER_IP} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3

[workers]
${workers}
"""
        }
      }
    }

    /* -------------------- ANSIBLE -------------------- */

    stage('Configure Kubernetes Cluster') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh '''
              ansible-playbook -i inventory.ini common-modules.yml
              ansible-playbook -i inventory.ini master.yml
              ansible-playbook -i inventory.ini worker.yml
            '''
          }
        }
      }
    }

    /* -------------------- MONITORING (BEFORE APP) -------------------- */

    stage('Deploy Monitoring') {
      steps {
        withCredentials([string(credentialsId: 'SLACK_WEBHOOK_URL', variable: 'SLACK_WEBHOOK_URL')]) {
          sshagent(credentials: [SSH_CREDS]) {
            sh '''
              sed "s|__SLACK_WEBHOOK__|$SLACK_WEBHOOK_URL|g" monitoring-values.yaml > monitoring-values-final.yaml

              scp -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  monitoring-values-final.yaml \
                ubuntu@${MASTER_IP}:/tmp/monitoring-values.yaml

              ssh -o StrictHostKeyChecking=no \
                  -o UserKnownHostsFile=/dev/null \
                  ubuntu@${MASTER_IP} '
                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true &&
                helm repo update &&
                helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
                  -n monitoring \
                  --create-namespace \
                  -f /tmp/monitoring-values.yaml \
                  --timeout 15m \
                  --wait
              '
            '''
          }
        }
      }
    }

    /* -------------------- APPLICATION -------------------- */

    stage('Deploy Application to Kubernetes') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh """
              ansible-playbook -i inventory.ini deploy-app.yml \
                -e IMAGE_NAME=${IMAGE_NAME} \
                -e IMAGE_TAG=${IMAGE_TAG} \
                -e ADMIN_IP_CIDR=${params.ADMIN_IP_CIDR}
            """
          }
        }
      }
    }
  }

  post {
    success {
      echo "✅ CI/CD + Kubernetes + Monitoring + Slack Alerts completed successfully"
    }
    failure {
      echo "❌ Pipeline failed. Check logs."
    }
  }
}