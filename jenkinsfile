pipeline {
  agent any

  parameters {
    booleanParam(
      name: 'RUN_TERRAFORM',
      defaultValue: false,
      description: 'Run Terraform apply (enable ONLY when infra changes)'
    )
  }

  environment {
    IMAGE_NAME   = "mohanreddybodha/feedback"
    IMAGE_TAG    = "v${BUILD_NUMBER}"
    DOCKER_CREDS = "dockerhub-creds"
    SSH_CREDS    = "ec2-ssh-key"

    ANSIBLE_HOST_KEY_CHECKING = "False"
  }

  options {
    timeout(time: 30, unit: 'MINUTES')
    timestamps()
    disableConcurrentBuilds()
  }

  stages {

    /* -------------------- CODE -------------------- */

    stage('Checkout Code') {
      steps {
        checkout scm
      }
    }

    stage('Install Dependencies') {
      parallel {
        stage('Backend Deps') {
          steps { sh 'cd backend && npm install' }
        }
        stage('Frontend Deps') {
          steps { sh 'cd frontend && npm install' }
        }
      }
    }

    stage('Build Frontend') {
      steps {
        sh '''
          cd frontend
          npm run build || echo "Static build skipped"
          mkdir -p ../backend/public
          cp -r dist/* ../backend/public/ || true
        '''
      }
    }

    stage('Test Backend') {
      steps {
        sh 'cd backend && node -c server.js'
      }
    }

    /* -------------------- DOCKER -------------------- */

    stage('Build & Push Docker Image') {
      steps {
        script {
          docker.withRegistry('https://index.docker.io/v1/', DOCKER_CREDS) {
            sh '''
              docker build -t $IMAGE_NAME:$IMAGE_TAG .
              docker push $IMAGE_NAME:$IMAGE_TAG
            '''
          }
        }
      }
    }

    /* -------------------- TERRAFORM -------------------- */

    stage('Terraform Init & Apply') {
      when {
        expression { params.RUN_TERRAFORM == true }
      }
      steps {
        dir('terraform') {
          sh '''
            terraform init -input=false
            terraform apply -auto-approve -input=false
          '''
        }
      }
    }

    /* -------------------- INVENTORY -------------------- */

    stage('Generate Ansible Inventory') {
      steps {
        script {
          env.MASTER_IP = sh(
            script: "cd terraform && terraform output -raw master_ip",
            returnStdout: true
          ).trim()

          def worker_ips = sh(
            script: "cd terraform && terraform output -json worker_ips | jq -r '.[]'",
            returnStdout: true
          ).trim()

          def workers = worker_ips.split('\n')
            .collect { ip ->
              "${ip} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3"
            }.join('\n')

          writeFile file: "ansible/inventory.ini", text: """
[master]
${env.MASTER_IP} ansible_user=ubuntu ansible_python_interpreter=/usr/bin/python3

[workers]
${workers}
"""
        }
      }
    }

    /* -------------------- ANSIBLE -------------------- */

    stage('Configure Kubernetes Cluster') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh '''
              ansible-playbook -i inventory.ini bootstrap.yml
              ansible-playbook -i inventory.ini common.yml
              ansible-playbook -i inventory.ini master.yml
              ansible-playbook -i inventory.ini worker.yml
            '''
          }
        }
      }
    }

    stage('Deploy Application to Kubernetes') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          dir('ansible') {
            sh """
              ansible-playbook -i inventory.ini deploy-app.yml \
                -e image_name=${IMAGE_NAME} \
                -e image_tag=${IMAGE_TAG}
            """
          }
        }
      }
    }

    /* -------------------- MONITORING -------------------- */

    stage('Deploy Monitoring') {
      steps {
        sshagent(credentials: [SSH_CREDS]) {
          sh """
            scp -o StrictHostKeyChecking=no monitoring-values.yaml ubuntu@${MASTER_IP}:/tmp/monitoring-values.yaml
            ssh -o StrictHostKeyChecking=no ubuntu@${MASTER_IP} '
              helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true &&
              helm repo update &&
              helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
                -n monitoring \
                --create-namespace \
                -f /tmp/monitoring-values.yaml
            '
          """
        }
      }
    }
  }

  post {
    success {
      echo "✅ CI/CD + Kubernetes + Monitoring pipeline completed successfully"
    }
    failure {
      echo "❌ Pipeline failed. Check logs."
    }
  }
}